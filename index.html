<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProTrax v38: Timeline Fixed</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Teko:wght@600;700&family=Roboto:wght@700;900&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #0f172a; color: #f1f5f9; }
        
        .workspace {
            position: relative;
            background: #000;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            border: 1px solid #1e293b;
            width: 100%;
            display: flex; justify-content: center; align-items: center;
        }

        #videoElement { width: 100%; max-height: 70vh; object-fit: contain; display: block; }
        #analysisCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; cursor: crosshair; z-index: 20; }

        /* Controls Container */
        .controls-area {
            background: #1e293b;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            border: 1px solid #334155;
        }

        /* Timeline Marker */
        .timeline-container { position: relative; width: 100%; height: 24px; display: flex; align-items: center; margin-bottom: 8px; }
        #seek { z-index: 20; position: relative; width: 100%; height: 100%; margin: 0; opacity: 0.8; cursor: pointer; }
        
        #timelineMarkers {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 15;
        }

        .t-marker {
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            z-index: 10; transition: left 0.1s ease;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        /* Marker Styles */
        .tm-impact {
            width: 10px; height: 10px; background: #ef4444; 
            transform: translate(-50%, -50%) rotate(45deg); border: 1px solid white;
        }
        .tm-mid {
            width: 8px; height: 8px; background: #facc15; 
            border-radius: 50%; border: 1px solid white;
        }
        .tm-apex {
            width: 0; height: 0; 
            border-left: 6px solid transparent; border-right: 6px solid transparent;
            border-bottom: 12px solid #06b6d4; 
            transform: translate(-50%, -50%); filter: drop-shadow(0 0 1px black);
        }
        .tm-landing {
            width: 10px; height: 10px; background: #22c55e; 
            border: 1px solid white;
        }

        /* Broadcast Overlay */
        #broadcastOverlay {
            position: absolute; top: 3%; left: 3%; z-index: 30; width: 20%; min-width: 130px; 
            container-type: inline-size; display: flex; flex-direction: column;
            box-shadow: 2px 4px 10px rgba(0,0,0,0.7);
            font-family: 'Teko', sans-serif; text-transform: uppercase; letter-spacing: -0.02em;
        }
        .row-top { display: flex; height: 20cqi; }
        .box-name { flex: 1; background: white; color: #111; display: flex; align-items: center; justify-content: center; font-size: 12cqi; font-weight: 700; white-space: nowrap; overflow: hidden; padding: 0 2cqi; line-height: 1; padding-top: 1cqi; }
        .box-score { width: 30%; background: #dc2626; color: white; display: flex; align-items: center; justify-content: center; font-size: 14.5cqi; font-weight: 700; line-height: 1; padding-top: 1cqi; }
        .row-mid { display: flex; height: 14cqi; background: #15803d; }
        .box-stats { flex: 1; color: white; display: flex; align-items: center; justify-content: center; padding-left: 0; font-size: 8.5cqi; font-weight: 600; gap: 2cqi; }
        .stat-group { display: flex; align-items: baseline; }
        .stat-label { font-size: 5cqi; margin-left: 1cqi; font-weight: 400; opacity: 0.9; }
        .box-shot { display: flex; align-items: center; padding-right: 1.5cqi; gap: 1cqi; }
        .shot-num { width: 8cqi; height: 8cqi; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 8cqi; border-radius: 2px; line-height: 1; padding-top: 0.5cqi; }
        .shot-active { background: white; color: #15803d; box-shadow: 0 1px 3px rgba(0,0,0,0.3); } 
        .shot-inactive { background: #0f5f2c; color: rgba(255,255,255,0.7); border: 1px solid rgba(255,255,255,0.1); }
        .row-bot { height: 11cqi; background: #facc15; color: #111; display: flex; align-items: center; justify-content: center; font-size: 7.2cqi; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 0 2cqi; padding-top: 0.5cqi; }

        /* Custom Slider */
        input[type=range] { -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #ffffff; margin-top: -6px; box-shadow: 0 0 0 2px #3b82f6; transition: transform 0.1s; position: relative; z-index: 30;}
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #475569; border-radius: 2px; }
    </style>
</head>
<body class="flex flex-col min-h-screen selection:bg-slate-500 selection:text-white">

    <!-- Navbar -->
    <nav class="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-30 sticky top-0">
        <div class="max-w-7xl mx-auto px-4 h-14 flex justify-between items-center">
            <div class="flex items-center gap-2">
                <i class="fa-solid fa-golf-ball-tee text-white text-lg"></i>
                <span class="font-bold text-lg tracking-wide">ProTrax <span class="text-slate-400 text-xs font-normal">v38 Timeline Fix</span></span>
            </div>
            <button onclick="location.reload()" class="text-xs text-slate-400 hover:text-white flex items-center gap-1 px-3 py-1 rounded hover:bg-slate-800 transition-colors">
                <i class="fa-solid fa-arrows-rotate"></i> 초기화
            </button>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow p-4 max-w-7xl mx-auto w-full grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        <!-- Left: Workspace -->
        <div class="lg:col-span-2 flex flex-col gap-2">
            <div class="workspace group" id="videoWrapper">
                <!-- Upload UI -->
                <div id="uploadUI" class="absolute inset-0 z-40 bg-slate-900/95 flex flex-col items-center justify-center border-2 border-dashed border-slate-700 m-4 rounded-xl cursor-pointer hover:border-white hover:bg-slate-800/50 transition-all group-hover:scale-[1.01]" onclick="document.getElementById('fileIn').click()">
                    <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mb-4 text-slate-400 group-hover:text-white group-hover:bg-slate-700 transition-all">
                        <i class="fa-solid fa-cloud-arrow-up text-3xl"></i>
                    </div>
                    <h3 class="text-xl font-bold text-slate-200">영상 파일 선택</h3>
                    <p class="text-sm text-slate-500 mt-2">MP4, MOV (소리 포함)</p>
                    <input type="file" id="fileIn" accept="video/*" class="hidden">
                </div>

                <!-- Export Loading Overlay -->
                <div id="exportOverlay" class="absolute inset-0 z-50 bg-black/90 hidden flex flex-col items-center justify-center text-white">
                    <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-3"></div>
                    <span class="font-bold text-lg">최대 화질 렌더링 중...</span>
                    <span class="text-xs text-slate-400 mt-1">25Mbps High Bitrate / Native Resolution</span>
                    <span class="text-xs text-slate-500 mt-4">완료 시 자동 다운로드됩니다.</span>
                </div>

                <!-- Preview Overlay -->
                <div id="broadcastOverlay" class="hidden">
                    <div class="row-top">
                        <div class="box-name" id="dispName">Rory McIlroy</div>
                        <div class="box-score" id="dispScore">-9</div>
                    </div>
                    <div class="row-mid">
                        <div class="box-stats">
                            <div class="stat-group"><span id="dispHole">16</span><span class="stat-label">TH</span></div>
                            <div class="stat-group"><span id="dispDist">455</span><span class="stat-label">YDS</span></div>
                        </div>
                        <div class="box-shot">
                            <div class="shot-num shot-active" id="shot1">1</div>
                            <div class="shot-num shot-inactive" id="shot2">2</div>
                            <div class="shot-num shot-inactive" id="shot3">3</div>
                            <div class="shot-num shot-inactive" id="shot4">4</div>
                        </div>
                    </div>
                    <div class="row-bot" id="dispCourse">Augusta National Golf Club</div>
                </div>

                <video id="videoElement" playsinline preload="auto" crossorigin="anonymous"></video>
                <canvas id="analysisCanvas"></canvas>
            </div>

            <!-- Separated Controls Area -->
            <div class="controls-area">
                <div class="timeline-container">
                    <div id="timelineMarkers">
                        <!-- JS injects markers here -->
                    </div>
                    <input type="range" id="seek" min="0" max="100" step="0.01" value="0">
                </div>
                
                <div class="flex justify-between items-center text-sm">
                    <div class="flex items-center gap-4">
                        <button id="btnPlay" class="w-10 h-10 bg-slate-700 rounded-full flex items-center justify-center hover:bg-slate-600 hover:text-white text-slate-300 transition-colors shadow"><i class="fa-solid fa-play"></i></button>
                        <div class="flex flex-col">
                            <span id="timeDisplay" class="font-mono text-white text-sm font-bold">00:00.00</span>
                            <span class="text-[10px] text-slate-400">Total Duration</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button id="btnPrevFrame" class="px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 text-xs text-white border border-slate-600 transition-colors" title="-1 Frame"><i class="fa-solid fa-chevron-left mr-1"></i> Frame</button>
                        <button id="btnNextFrame" class="px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 text-xs text-white border border-slate-600 transition-colors" title="+1 Frame">Frame <i class="fa-solid fa-chevron-right ml-1"></i></button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right: Dashboard -->
        <div class="flex flex-col gap-4">
            <div class="bg-slate-800 p-6 rounded-lg shadow-lg border border-slate-700 min-h-[200px] flex flex-col justify-between" id="instructionPanel">
                <div>
                    <div class="flex items-center gap-2 mb-3">
                        <span id="stepBadge" class="px-2 py-0.5 rounded text-[10px] font-bold bg-slate-700 text-slate-300 uppercase tracking-wider">Step 1</span>
                    </div>
                    <h2 class="text-xl font-bold text-white mb-2" id="msgTitle">준비됨</h2>
                    <p class="text-slate-400 text-sm leading-relaxed whitespace-pre-line" id="msgBody">영상을 업로드하면 분석을 시작합니다.</p>
                </div>
                
                <div class="flex flex-col gap-2 mt-4">
                    <button id="mainBtn" class="w-full py-3.5 bg-slate-700 text-slate-500 font-bold rounded-lg cursor-not-allowed transition-all shadow-sm" disabled>대기 중...</button>
                    
                    <div class="grid grid-cols-2 gap-2 hidden" id="resultBtns">
                        <button id="addInfoBtn" class="col-span-2 py-3 bg-green-700 hover:bg-green-600 text-white font-bold rounded-lg transition-all shadow-sm text-sm">
                            <i class="fa-solid fa-pen-to-square mr-1"></i> 방송 정보 입력
                        </button>
                        <button id="downloadBtn" class="col-span-2 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-lg transition-all shadow-sm text-sm flex items-center justify-center">
                            <i class="fa-solid fa-download mr-1"></i> 최대 화질 영상 저장 (Max)
                        </button>
                    </div>

                    <button id="undoBtn" class="w-full py-2 border border-slate-600 text-slate-400 rounded-lg hover:bg-slate-700 hidden text-xs transition-colors"><i class="fa-solid fa-rotate-left mr-1"></i> 이전 포인트 취소</button>
                </div>
            </div>

            <!-- Broadcast Info Input Panel -->
            <div id="infoInputPanel" class="hidden bg-slate-800 p-5 rounded-lg shadow-lg border border-slate-700 animate-in fade-in slide-in-from-right-4">
                <h3 class="text-sm font-bold text-white mb-4"><i class="fa-solid fa-pen mr-2"></i>중계 정보 입력</h3>
                <div class="space-y-3">
                    <div>
                        <label class="text-xs text-slate-400 font-bold">플레이어</label>
                        <input type="text" id="inName" value="Rory McIlroy" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-white text-sm">
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <div><label class="text-xs text-slate-400 font-bold">홀</label><input type="number" id="inHole" value="16" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-white text-sm"></div>
                        <div><label class="text-xs text-slate-400 font-bold">거리</label><input type="number" id="inDist" value="455" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-white text-sm"></div>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <div><label class="text-xs text-slate-400 font-bold">스코어</label><input type="text" id="inScore" value="-9" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-red-400 font-bold text-sm"></div>
                        <div><label class="text-xs text-slate-400 font-bold">샷</label><input type="number" id="inShot" value="1" min="1" max="4" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-white text-sm"></div>
                    </div>
                    <div>
                        <label class="text-xs text-slate-400 font-bold">골프장</label>
                        <input type="text" id="inCourse" value="Augusta National Golf Club" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-white text-sm">
                    </div>
                    <button id="confirmInfoBtn" class="w-full mt-2 py-2 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded text-sm transition-colors">적용하기</button>
                </div>
            </div>

            <!-- Stats -->
            <div id="statsPanel" class="hidden flex flex-col gap-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
                <div class="grid grid-cols-2 gap-3">
                    <div class="bg-slate-800 p-4 rounded-lg border border-slate-700">
                        <span class="text-[10px] text-slate-500 uppercase font-bold tracking-wider block mb-1">Flight Time</span>
                        <div class="text-xl font-bold text-white"><span id="statTime">0.0</span>s</div>
                    </div>
                    <div class="bg-slate-800 p-4 rounded-lg border border-slate-700">
                        <span class="text-[10px] text-slate-500 uppercase font-bold tracking-wider block mb-1">Apex Height</span>
                        <div class="text-xl font-bold text-white" id="statHeight">--</div>
                    </div>
                </div>
                <div class="bg-slate-800 p-4 rounded-lg border border-slate-700 h-48">
                    <canvas id="chart"></canvas>
                </div>
            </div>

            <!-- Steps -->
            <div class="bg-slate-800 rounded-lg p-4 grid grid-cols-5 gap-1 text-center text-xs border border-slate-700 shadow-sm">
                <div id="step1" class="text-white font-bold border-b-2 border-white pb-2">1. 타격</div>
                <div id="step2" class="text-slate-500 border-b-2 border-transparent pb-2">2. 중간궤적</div>
                <div id="step3" class="text-slate-500 border-b-2 border-transparent pb-2">3. 낙하</div>
                <div id="step4" class="text-slate-500 border-b-2 border-transparent pb-2">4. 결과</div>
                <div id="step5" class="text-slate-500 border-b-2 border-transparent pb-2">5. 정보</div>
            </div>
        </div>
    </main>

    <script>
        const App = {
            step: 0, 
            video: { el: null, dur: 0, w: 0, h: 0, playing: false },
            points: [], 
            splinePath: [],
            lag: 0.1,
            isRecording: false,
            recorder: null,
            chunks: []
        };

        const UI = {
            file: document.getElementById('fileIn'),
            upload: document.getElementById('uploadUI'),
            canvas: document.getElementById('analysisCanvas'),
            ctx: document.getElementById('analysisCanvas').getContext('2d'),
            seek: document.getElementById('seek'),
            timelineMarkers: document.getElementById('timelineMarkers'), // Timeline Markers
            time: document.getElementById('timeDisplay'),
            btnPlay: document.getElementById('btnPlay'),
            btnPrev: document.getElementById('btnPrevFrame'),
            btnNext: document.getElementById('btnNextFrame'),
            steps: [1,2,3,4,5].map(n => document.getElementById(`step${n}`)),
            title: document.getElementById('msgTitle'),
            body: document.getElementById('msgBody'),
            btn: document.getElementById('mainBtn'),
            resultBtns: document.getElementById('resultBtns'),
            dlBtn: document.getElementById('downloadBtn'),
            addInfoBtn: document.getElementById('addInfoBtn'),
            undo: document.getElementById('undoBtn'),
            stats: document.getElementById('statsPanel'),
            badge: document.getElementById('stepBadge'),
            exportOverlay: document.getElementById('exportOverlay'),
            // Info
            infoPanel: document.getElementById('infoInputPanel'),
            overlay: document.getElementById('broadcastOverlay'),
            confirmInfo: document.getElementById('confirmInfoBtn'),
            inputs: {
                name: document.getElementById('inName'),
                score: document.getElementById('inScore'),
                hole: document.getElementById('inHole'),
                dist: document.getElementById('inDist'),
                shot: document.getElementById('inShot'),
                course: document.getElementById('inCourse')
            },
            displays: {
                name: document.getElementById('dispName'),
                score: document.getElementById('dispScore'),
                hole: document.getElementById('dispHole'),
                dist: document.getElementById('dispDist'),
                course: document.getElementById('dispCourse')
            }
        };

        // --- Init ---
        window.onload = () => {
            App.video.el = document.getElementById('videoElement');
            UI.file.addEventListener('change', loadVideo);
            
            App.video.el.addEventListener('loadedmetadata', onVideoReady);
            App.video.el.addEventListener('timeupdate', onTimeUpdate);
            App.video.el.addEventListener('ended', onVideoEnded);

            UI.btnPlay.addEventListener('click', togglePlay);
            UI.seek.addEventListener('input', (e) => {
                if(App.isRecording) return;
                App.video.el.currentTime = e.target.value;
                render();
            });
            UI.seek.addEventListener('mousedown', () => !App.isRecording && App.video.el.pause());
            
            UI.btnPrev.addEventListener('click', () => !App.isRecording && frameStep(-0.033));
            UI.btnNext.addEventListener('click', () => !App.isRecording && frameStep(0.033));

            UI.canvas.addEventListener('mousedown', onCanvasClick);
            UI.btn.addEventListener('click', onMainAction);
            UI.addInfoBtn.addEventListener('click', () => setStep(5));
            UI.confirmInfo.addEventListener('click', () => {
                updateOverlay();
                const originalText = UI.confirmInfo.innerText;
                UI.confirmInfo.innerHTML = '<i class="fa-solid fa-check mr-1"></i> 적용 완료!';
                UI.confirmInfo.classList.remove('bg-blue-600', 'hover:bg-blue-500');
                UI.confirmInfo.classList.add('bg-green-600', 'hover:bg-green-500');
                setTimeout(() => {
                    setStep(4); 
                    setTimeout(() => {
                        UI.confirmInfo.innerText = originalText;
                        UI.confirmInfo.classList.add('bg-blue-600', 'hover:bg-blue-500');
                        UI.confirmInfo.classList.remove('bg-green-600', 'hover:bg-green-500');
                    }, 500);
                }, 1000);
            });
            UI.undo.addEventListener('click', onUndo);
            UI.dlBtn.addEventListener('click', startExport);

            window.addEventListener('resize', () => {
                render();
                if(App.step===5 || !UI.overlay.classList.contains('hidden')) {
                    adjustFontSize(UI.displays.name);
                    adjustFontSize(UI.displays.course);
                }
            });
            requestAnimationFrame(animLoop);
        };

        // --- Marker Update Logic ---
        function updateTimelineMarkers() {
            UI.timelineMarkers.innerHTML = ''; // Clear existing
            
            if (App.video.dur === 0) return;

            App.points.forEach((p, idx) => {
                const pct = (p.t / App.video.dur) * 100;
                const marker = document.createElement('div');
                marker.className = 't-marker';
                marker.style.left = `${pct}%`;

                if (p.type === 'start') {
                    marker.classList.add('tm-impact');
                    marker.title = "Impact";
                } else if (p.type === 'mid') {
                    // Check if this is the LAST mid point (Apex)
                    // Find index of last mid point
                    let lastMidIndex = -1;
                    for(let i = App.points.length-1; i>=0; i--) {
                        if(App.points[i].type === 'mid') {
                            lastMidIndex = i;
                            break;
                        }
                    }

                    if (idx === lastMidIndex) {
                         marker.classList.add('tm-apex');
                         marker.title = "Apex";
                    } else {
                         marker.classList.add('tm-mid');
                         marker.title = "Mid";
                    }
                } else if (p.type === 'end') {
                    marker.classList.add('tm-landing');
                    marker.title = "Landing";
                }
                
                UI.timelineMarkers.appendChild(marker);
            });
        }


        function adjustFontSize(element) {
            if (!element) return;
            element.style.fontSize = "";
            if (element.scrollWidth > element.clientWidth) {
                let currentSize = parseFloat(window.getComputedStyle(element).fontSize);
                while (element.scrollWidth > element.clientWidth && currentSize > 8) {
                    currentSize -= 0.5;
                    element.style.fontSize = currentSize + "px";
                }
            }
        }

        function loadVideo(e) {
            const f = e.target.files[0];
            if(!f) return;
            App.video.el.src = URL.createObjectURL(f);
            App.video.el.muted = false; 
            UI.upload.classList.add('hidden');
        }

        function onVideoReady() {
            App.video.dur = App.video.el.duration;
            App.video.w = App.video.el.videoWidth;
            App.video.h = App.video.el.videoHeight;
            // Set canvas size to match video resolution for export quality
            UI.canvas.width = App.video.w;
            UI.canvas.height = App.video.h;
            
            UI.seek.max = App.video.dur;
            setStep(1);
            render();
            updateTimelineMarkers();
        }

        function togglePlay() {
            if(App.isRecording) return;
            if(App.video.el.paused) {
                App.video.el.play();
                App.video.playing = true;
            } else {
                App.video.el.pause();
                App.video.playing = false;
            }
            updatePlayIcon();
        }

        function updatePlayIcon() {
            UI.btnPlay.innerHTML = App.video.playing ? '<i class="fa-solid fa-pause"></i>' : '<i class="fa-solid fa-play"></i>';
        }

        function frameStep(dt) {
            App.video.el.pause();
            App.video.playing = false;
            updatePlayIcon();
            App.video.el.currentTime = Math.max(0, Math.min(App.video.dur, App.video.el.currentTime + dt));
        }

        function onTimeUpdate() {
            if(App.video.playing) UI.seek.value = App.video.el.currentTime;
            UI.time.textContent = App.video.el.currentTime.toFixed(2);
        }

        function onVideoEnded() {
            App.video.playing = false;
            updatePlayIcon();
            if(App.isRecording) stopExport();
        }

        // --- Export Logic ---
        function startExport() {
            if(App.isRecording) return;
            App.isRecording = true;
            UI.exportOverlay.classList.remove('hidden');
            
            App.video.el.pause();
            App.video.el.currentTime = 0; 

            const canvasStream = UI.canvas.captureStream(60); 
            // Try to capture audio from video
            try {
                let vStream = null;
                if(App.video.el.captureStream) vStream = App.video.el.captureStream();
                else if(App.video.el.mozCaptureStream) vStream = App.video.el.mozCaptureStream();
                if(vStream && vStream.getAudioTracks().length > 0) {
                    canvasStream.addTrack(vStream.getAudioTracks()[0]);
                }
            } catch(e) {}

            App.chunks = [];
            // Force High Bitrate for Quality
            const options = { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: 25000000 };
            
            try {
                App.recorder = new MediaRecorder(canvasStream, options);
            } catch(e) {
                try {
                    App.recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm', videoBitsPerSecond: 15000000 });
                } catch(e2) {
                    App.recorder = new MediaRecorder(canvasStream);
                }
            }

            App.recorder.ondataavailable = e => { if(e.data.size > 0) App.chunks.push(e.data); };
            App.recorder.start();
            App.video.el.play();
            App.video.playing = true;
        }

        function stopExport() {
            App.recorder.stop();
            App.isRecording = false;
            UI.exportOverlay.classList.add('hidden');
            
            App.recorder.onstop = () => {
                const blob = new Blob(App.chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'protrax_analysis.webm';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            };
        }

        // --- Canvas Drawing for Overlay (Export) ---
        function drawCanvasOverlay(ctx) {
            // Only draw if info exists
            if (UI.overlay.classList.contains('hidden')) return;

            const W = UI.canvas.width;
            const H = UI.canvas.height;
            const scale = W / 1280; // Base scale on 720p width approx

            const boxW = 260 * scale;
            const top = 30 * scale;
            const left = 30 * scale;
            const row1H = 50 * scale;
            const row2H = 35 * scale;
            const row3H = 30 * scale;

            ctx.font = `bold ${24*scale}px "Teko", sans-serif`;
            ctx.textBaseline = 'middle';

            // Row 1: Name & Score
            // Name Box (White)
            ctx.fillStyle = 'white';
            ctx.fillRect(left, top, boxW * 0.75, row1H);
            ctx.fillStyle = '#111';
            ctx.textAlign = 'center';
            // Auto fit name
            let fontSize = 24*scale;
            ctx.font = `bold ${fontSize}px "Teko", sans-serif`;
            const nameText = UI.inputs.name.value.toUpperCase();
            while(ctx.measureText(nameText).width > (boxW*0.7) && fontSize > 10) {
                fontSize--;
                ctx.font = `bold ${fontSize}px "Teko", sans-serif`;
            }
            ctx.fillText(nameText, left + (boxW*0.75)/2, top + row1H/2 + (2*scale));

            // Score Box (Red)
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(left + boxW * 0.75, top, boxW * 0.25, row1H);
            ctx.fillStyle = 'white';
            ctx.font = `bold ${28*scale}px "Roboto", sans-serif`;
            ctx.fillText(UI.inputs.score.value, left + boxW * 0.75 + (boxW*0.25)/2, top + row1H/2 + (2*scale));

            // Row 2: Stats & Shot
            const top2 = top + row1H;
            ctx.fillStyle = '#15803d';
            ctx.fillRect(left, top2, boxW, row2H);
            
            // Stats Text
            ctx.fillStyle = 'white';
            ctx.textAlign = 'left';
            ctx.font = `bold ${18*scale}px "Roboto", sans-serif`;
            
            // Hole
            const holeX = left + 10*scale;
            ctx.fillText(UI.inputs.hole.value, holeX, top2 + row2H/2);
            const holeW = ctx.measureText(UI.inputs.hole.value).width;
            ctx.font = `400 ${12*scale}px "Roboto", sans-serif`;
            ctx.fillText("TH", holeX + holeW + 2*scale, top2 + row2H/2);

            // Dist
            ctx.font = `bold ${18*scale}px "Roboto", sans-serif`;
            const distX = holeX + holeW + 35*scale;
            ctx.fillText(UI.inputs.dist.value, distX, top2 + row2H/2);
            const distW = ctx.measureText(UI.inputs.dist.value).width;
            ctx.font = `400 ${12*scale}px "Roboto", sans-serif`;
            ctx.fillText("YDS", distX + distW + 2*scale, top2 + row2H/2);

            // Shot Tiles
            const shotVal = parseInt(UI.inputs.shot.value);
            const tileS = 20*scale;
            const gap = 3*scale;
            const startX = left + boxW - (4*tileS + 3*gap) - 10*scale;
            
            for(let i=1; i<=4; i++) {
                const x = startX + (i-1)*(tileS+gap);
                const y = top2 + (row2H - tileS)/2;
                
                if(i === shotVal) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x, y, tileS, tileS);
                    ctx.fillStyle = '#15803d';
                } else {
                    ctx.fillStyle = '#0f5f2c'; // Darker green
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, tileS, tileS);
                    ctx.fillRect(x, y, tileS, tileS);
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                }
                
                ctx.font = `bold ${14*scale}px "Roboto", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i, x + tileS/2, y + tileS/2 + 1*scale);
            }

            // Row 3: Course
            const top3 = top2 + row2H;
            ctx.fillStyle = '#facc15';
            ctx.fillRect(left, top3, boxW, row3H);
            ctx.fillStyle = '#111';
            ctx.textAlign = 'center';
            
            fontSize = 16*scale;
            ctx.font = `bold ${fontSize}px "Teko", sans-serif`;
            const courseText = UI.inputs.course.value.toUpperCase();
            while(ctx.measureText(courseText).width > (boxW*0.9) && fontSize > 8) {
                fontSize--;
                ctx.font = `bold ${fontSize}px "Teko", sans-serif`;
            }
            ctx.fillText(courseText, left + boxW/2, top3 + row3H/2 + 1*scale);
        }

        // --- Logic ---
        function setStep(s) {
            App.step = s;
            updateUI();
        }

        function updateUI() {
            UI.steps.forEach((el, i) => {
                if(!el) return; 
                const isActive = (i+1 === App.step);
                const isPast = (i+1 < App.step);
                let colorClass = "text-slate-600 border-transparent"; 
                if (isActive) colorClass = "text-white border-white font-bold";
                else if (isPast) colorClass = "text-slate-400 border-slate-700 opacity-60";
                el.className = `border-b-2 pb-2 transition-all ${colorClass}`;
                if (isActive) {
                    UI.badge.innerText = `STEP ${i+1}`;
                    UI.badge.className = "px-2 py-0.5 rounded text-[10px] font-bold bg-white text-slate-900 uppercase tracking-wider";
                }
            });
            
            UI.undo.classList.add('hidden');
            UI.btn.classList.remove('hidden');
            UI.resultBtns.classList.add('hidden');
            UI.infoPanel.classList.add('hidden');
            
            switch(App.step) {
                case 1:
                    UI.title.innerText = "타격 시점 (Impact) 설정";
                    UI.body.innerText = "공이 타격되는 순간(Impact)의 위치를 정확히 클릭하세요.";
                    setBtn("위치 클릭 대기중", false);
                    break;
                case 2:
                    UI.title.innerText = "중간 궤적 입력";
                    UI.body.innerHTML = "공이 날아가는 경로를 따라 1개 이상의 점을 클릭하세요.<br><b>마지막 점이 최고점(APEX)으로 기록됩니다.</b>";
                    const ptCount = App.points.filter(p => p.type === 'mid').length;
                    setBtn(ptCount >= 1 ? "다음: 낙하지점 설정" : "최소 1개 이상 입력", ptCount >= 1, "bg-slate-600 hover:bg-slate-500 text-white");
                    UI.undo.classList.remove('hidden');
                    break;
                case 3:
                    UI.title.innerText = "낙하지점 (Landing Point) 설정";
                    UI.body.innerText = "공이 지면에 닿는 순간을 찾아 클릭하세요. 궤적의 끝점입니다.";
                    setBtn("위치 클릭 대기중", false);
                    UI.undo.classList.remove('hidden');
                    break;
                case 4:
                    UI.title.innerText = "분석 완료";
                    UI.body.innerText = "화이트 혜성 궤적을 확인하세요. \n정보를 추가하고 영상을 저장할 수 있습니다.";
                    UI.btn.classList.add('hidden');
                    UI.resultBtns.classList.remove('hidden');
                    UI.resultBtns.className = "grid grid-cols-2 gap-2";
                    UI.stats.classList.remove('hidden');
                    break;
                case 5:
                    UI.title.innerText = "방송 정보 입력";
                    UI.body.innerText = "화면 좌측 상단에 표시될 플레이어 및 코스 정보를 입력하세요.";
                    UI.btn.classList.add('hidden');
                    UI.stats.classList.add('hidden');
                    UI.infoPanel.classList.remove('hidden');
                    updateOverlay(); 
                    break;
            }
        }

        function setBtn(txt, active, cls) {
            UI.btn.innerText = txt;
            UI.btn.disabled = !active;
            UI.btn.className = active 
                ? (cls || "w-full py-3.5 bg-white hover:bg-gray-200 text-slate-900 font-bold rounded-lg transition-all shadow-lg")
                : "w-full py-3.5 bg-slate-700 text-slate-500 font-bold rounded-lg cursor-not-allowed transition-all";
        }

        function onMainAction() {
            if(App.step === 2) {
                setStep(3);
                App.video.el.currentTime = Math.min(App.video.dur, App.video.el.currentTime + 1.5);
            } else if(App.step === 4) {
                // Replay not on main button anymore
            }
        }

        function updateOverlay() {
            UI.displays.name.innerText = UI.inputs.name.value;
            UI.displays.score.innerText = UI.inputs.score.value;
            UI.displays.hole.innerText = UI.inputs.hole.value;
            UI.displays.dist.innerText = UI.inputs.dist.value;
            UI.displays.course.innerText = UI.inputs.course.value;

            const shot = parseInt(UI.inputs.shot.value);
            for(let i=1; i<=4; i++) {
                const el = document.getElementById(`shot${i}`);
                if(i === shot) {
                    el.className = "shot-num shot-active";
                } else {
                    el.className = "shot-num shot-inactive";
                }
            }
            UI.overlay.classList.remove('hidden');
            adjustFontSize(UI.displays.name);
            adjustFontSize(UI.displays.course);
        }

        function onUndo() {
            if(App.points.length > 0) {
                App.points.pop();
                if(App.points.length === 0) { 
                    setStep(1); 
                    // Remove impact marker
                    updateTimelineMarkers();
                }
                else if(App.points.length > 0 && App.points[App.points.length-1].type === 'start') setStep(2);
                else updateUI();
                render();
                updateTimelineMarkers();
            }
        }

        function onCanvasClick(e) {
            if(App.step === 5 || App.isRecording) return;

            const rect = UI.canvas.getBoundingClientRect();
            // Match canvas size to visual size for sharp editing overlay
            // However, for Export, we need native resolution mapping.
            
            // Revert to NATIVE Resolution for consistent drawing
            if(App.isRecording) {
                UI.canvas.width = App.video.w;
                UI.canvas.height = App.video.h;
            } else {
                // Editing mode: Canvas matches display size
                UI.canvas.width = rect.width;
                UI.canvas.height = rect.height;
            }

            const w = UI.canvas.width;
            const h = UI.canvas.height;

            // Map Normalized to Canvas Pixels
            
            let ox = 0, oy = 0, scale = 1;
            
            if(App.isRecording) {
                // Video fills canvas exactly
                scale = 1; ox = 0; oy = 0;
                const toPx = (nx, ny) => ({ x: nx * w, y: ny * h });
                
                if (App.step >= 4) {
                    // Draw Video First
                    UI.ctx.drawImage(App.video.el, 0, 0, w, h);
                    drawMeteorTrajectory(UI.ctx, toPx);
                    drawCanvasOverlay(UI.ctx); 
                }
            } else {
                // Edit Mode: Need to simulate object-fit:contain mapping
                const ratioW = w / App.video.w;
                const ratioH = h / App.video.h;
                scale = Math.min(ratioW, ratioH);
                const vidW = App.video.w * scale;
                const vidH = App.video.h * scale;
                ox = (w - vidW) / 2;
                oy = (h - vidH) / 2;
                
                const toScreen = (nx, ny) => ({ x: ox + nx * vidW, y: oy + ny * vidH });

                // Check click vs visual area
                const rect = UI.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                // Inverse map to normalized
                const normX = (mx - ox) / vidW;
                const normY = (my - oy) / vidH;

                if (normX < 0 || normX > 1 || normY < 0 || normY > 1) return;

                const t = App.video.el.currentTime;
                const pt = { t, nx: normX, ny: normY, type: '' };

                if (App.step === 1) {
                    pt.type = 'start';
                    App.points = [pt];
                    App.video.el.currentTime += 0.04; 
                    setStep(2);
                } else if(App.step === 2) {
                    if(t <= App.points[0].t) { alert("타격 시점보다 뒤의 시간을 선택하세요."); return; }
                    pt.type = 'mid';
                    App.points.push(pt);
                    App.points.sort((a,b) => a.t - b.t);
                    updateUI();
                } else if(App.step === 3) {
                    const lastPt = App.points[App.points.length-1];
                    if(t <= lastPt.t) { alert("이전 점보다 뒤의 시간을 선택하세요."); return; }
                    pt.type = 'end';
                    App.points.push(pt);
                    calculateSpline();
                    setStep(4);
                }
                render();
                updateTimelineMarkers();
            }
        }

        function calculateSpline() {
            const P = App.points.sort((a,b) => a.t - b.t);
            App.splinePath = [];
            const stepsPerSegment = 40; 
            for(let i = 0; i < P.length - 1; i++) {
                const p0 = i > 0 ? P[i-1] : P[i];
                const p1 = P[i];
                const p2 = P[i+1];
                const p3 = i < P.length - 2 ? P[i+2] : P[i+1];
                for(let s = 0; s < stepsPerSegment; s++) {
                    const t = s / stepsPerSegment;
                    const tt = t * t;
                    const ttt = tt * t;
                    const q1 = -ttt + 2*tt - t;
                    const q2 = 3*ttt - 5*tt + 2;
                    const q3 = -3*ttt + 4*tt + t;
                    const q4 = ttt - tt;
                    const nx = 0.5 * (p0.nx * q1 + p1.nx * q2 + p2.nx * q3 + p3.nx * q4);
                    const ny = 0.5 * (p0.ny * q1 + p1.ny * q2 + p2.ny * q3 + p3.ny * q4);
                    const time = p1.t + (p2.t - p1.t) * t;
                    App.splinePath.push({ nx, ny, t: time });
                }
            }
            const last = P[P.length-1];
            App.splinePath.push({ nx: last.nx, ny: last.ny, t: last.t });
            updateStats();
        }

        function updateStats() {
            const start = App.points[0];
            const end = App.points[App.points.length-1];
            document.getElementById('statTime').innerText = (end.t - start.t).toFixed(2);
            let minNy = 1;
            App.splinePath.forEach(p => { if(p.ny < minNy) minNy = p.ny; });
            const pxHeight = (start.ny - minNy) * App.video.h;
            document.getElementById('statHeight').innerText = Math.round(pxHeight) + "px";
            renderChart();
        }

        function animLoop() {
            if(App.video.playing) {
                UI.seek.value = App.video.el.currentTime;
                UI.time.textContent = App.video.el.currentTime.toFixed(2);
                render();
            }
            requestAnimationFrame(animLoop);
        }

        function render() {
            const ctx = UI.ctx;
            const rect = UI.canvas.getBoundingClientRect();
            // Match canvas size to visual size for sharp editing overlay
            UI.canvas.width = rect.width;
            UI.canvas.height = rect.height;

            // Revert to NATIVE Resolution for consistent drawing
            if(App.isRecording) {
                UI.canvas.width = App.video.w;
                UI.canvas.height = App.video.h;
            } else {
                // Editing mode: Canvas matches display size
                UI.canvas.width = rect.width;
                UI.canvas.height = rect.height;
            }

            const w = UI.canvas.width;
            const h = UI.canvas.height;

            if(App.isRecording) {
                // Draw Video Frame manually for export
                ctx.drawImage(App.video.el, 0, 0, w, h);
            } else {
                ctx.clearRect(0,0, w, h);
            }

            // Map Normalized to Canvas Pixels
            
            let ox = 0, oy = 0, scale = 1;
            
            if(App.isRecording) {
                // Video fills canvas exactly
                scale = 1; ox = 0; oy = 0;
                // BUT, App.points were stored assuming object-fit: contain relative to screen.
                // Actually, points are stored as Normalized (0-1) relative to the video frame itself.
                // So:
                const toPx = (nx, ny) => ({ x: nx * w, y: ny * h });
                
                if (App.step >= 4) {
                    drawMeteorTrajectory(ctx, toPx);
                    drawCanvasOverlay(ctx); // Draw the scoreboard
                }
            } else {
                // Edit Mode: Need to simulate object-fit:contain mapping
                const ratioW = w / App.video.w;
                const ratioH = h / App.video.h;
                scale = Math.min(ratioW, ratioH);
                const vidW = App.video.w * scale;
                const vidH = App.video.h * scale;
                ox = (w - vidW) / 2;
                oy = (h - vidH) / 2;
                
                const toScreen = (nx, ny) => ({ x: ox + nx * vidW, y: oy + ny * vidH });

                if (App.step >= 4) {
                    drawMeteorTrajectory(ctx, toScreen);
                } else {
                    drawSimpleTrajectory(ctx, toScreen);
                    drawPoints(ctx, toScreen);
                }
            }
        }

        function drawPoints(ctx, toScreen) {
            App.points.forEach((p, i) => {
                const pos = toScreen(p.nx, p.ny);
                let radius = 6;
                let color = '#fbbf24'; 
                let border = '#fff';
                let label = '';
                if(p.type === 'start') {
                    radius = 6; color = '#ffffff'; label = 'S';
                } else if(p.type === 'mid') {
                    radius = 3; color = '#fbbf24'; 
                } else if(p.type === 'end') {
                    radius = 6; color = 'rgba(255, 255, 255, 0.8)'; border = '#ffffff'; label = 'Landing Point'; 
                }
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI*2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = border;
                ctx.lineWidth = 2;
                ctx.stroke();
                if(label) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillText(label, pos.x + radius + 4, pos.y + 4);
                }
            });
        }

        function drawSimpleTrajectory(ctx, toScreen) {
            if(App.splinePath.length === 0) return;
            ctx.beginPath();
            const start = toScreen(App.splinePath[0].nx, App.splinePath[0].ny);
            ctx.moveTo(start.x, start.y);
            App.splinePath.forEach(p => ctx.lineTo(toScreen(p.nx, p.ny).x, toScreen(p.nx, p.ny).y));
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; 
            ctx.lineWidth = 3; 
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        function drawMeteorTrajectory(ctx, toScreen) {
            if(App.splinePath.length === 0) return;

            const now = App.video.el.currentTime;
            const drawLimit = now - App.lag; 
            const activePts = App.splinePath.filter(p => p.t <= drawLimit);
            const screenPts = activePts.map(p => toScreen(p.nx, p.ny));

            if(screenPts.length > 1) {
                const ARROW_LEN = 6; 
                let distAcc = 0;
                let cutIndex = screenPts.length - 1;
                let cutPoint = screenPts[screenPts.length - 1];
                
                for (let i = screenPts.length - 1; i > 0; i--) {
                    const p1 = screenPts[i];
                    const p2 = screenPts[i-1];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (distAcc + d >= ARROW_LEN) {
                        const remaining = ARROW_LEN - distAcc; 
                        const ratio = remaining / d; 
                        cutPoint = {
                            x: p1.x + (p2.x - p1.x) * ratio,
                            y: p1.y + (p2.y - p1.y) * ratio
                        };
                        cutIndex = i - 1;
                        break;
                    }
                    distAcc += d;
                    cutIndex = i - 1;
                }

                const totalPoints = cutIndex + 1;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = 3; 

                if(totalPoints > 1) {
                    for(let i = 0; i < totalPoints - 1; i++) {
                        const ptA = screenPts[i];
                        const ptB = screenPts[i+1];
                        const alpha = Math.pow(i / totalPoints, 2); 
                        ctx.beginPath();
                        ctx.moveTo(ptA.x, ptA.y);
                        ctx.lineTo(ptB.x, ptB.y);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; 
                        ctx.stroke();
                    }
                    const ptLast = screenPts[totalPoints-1];
                    ctx.beginPath();
                    ctx.moveTo(ptLast.x, ptLast.y);
                    ctx.lineTo(cutPoint.x, cutPoint.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, 1.0)`; 
                    ctx.stroke();
                }
                drawArrow(ctx, activePts, toScreen);
            }
        }

        function drawArrow(ctx, activePts, toScreen) {
            if (activePts.length < 2) return;
            const lastPt = activePts[activePts.length-1];
            const prevPt = activePts[activePts.length-2];
            const lastPos = toScreen(lastPt.nx, lastPt.ny);
            const prevPos = toScreen(prevPt.nx, prevPt.ny);
            
            const angle = Math.atan2(lastPos.y - prevPos.y, lastPos.x - prevPos.x);
            
            ctx.save();
            ctx.translate(lastPos.x, lastPos.y);
            ctx.rotate(angle);
            
            // Rounded Arrow
            ctx.beginPath();
            ctx.moveTo(2, 0); 
            ctx.lineTo(-6, -4);
            ctx.quadraticCurveTo(-4, 0, -6, 4);
            ctx.closePath();
            
            ctx.fillStyle = '#ffffff'; 
            ctx.fill();
            
            const g = ctx.createRadialGradient(0, 0, 1, 0, 0, 8);
            g.addColorStop(0, 'rgba(255,255,255,0.8)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

        // --- Chart ---
        let chart = null;
        function renderChart() {
            if(chart) chart.destroy();
            const ctx = document.getElementById('chart').getContext('2d');
            const startY = App.points[0].ny;
            const data = App.splinePath.map(p => (startY - p.ny) * 100); 
            const labels = App.splinePath.map(p => (p.t - App.points[0].t).toFixed(1));

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Height',
                        data: data,
                        borderColor: '#ffffff', // White Chart Line
                        backgroundColor: (context) => {
                            const ctx = context.chart.ctx;
                            const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                            gradient.addColorStop(0, 'rgba(255,255,255,0.5)');
                            gradient.addColorStop(1, 'rgba(255,255,255,0)');
                            return gradient;
                        },
                        fill: true,
                        pointRadius: 0,
                        tension: 0.4, 
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: {display: false}, tooltip: {mode: 'index', intersect: false} },
                    scales: { x: {display: false}, y: {display: false} }
                }
            });
        }
    </script>
</body>
</html>
